//포인터와 배열

/*
*(array+i)==array[i];
&p[0]==p+0

1차원 포인터 변수가 2차원 배열의 시작 주소를 저장해도 1차원 배열처럼 접근할 수 밖에없다. [0][2]안댐,
int *p를 **p로 대체해도 문제가 발생하지 않는다. 
=배열 포인터 변수라는 것을 사용해야함. 

int(*p)[열 길이];

포인터 배열 = 포인터가 많아지면 관리하려고
int* pointer[배열 길이]={NULL,NULL,NULL}


문자열의 맨 끝에는 문자열의 끝을 알리는 종료 문자 \0이 삽입되어있다. 
널 문자라고 부른다. 아스키 코드 정수 0이다. 
널 포인터는 주소로 0을 의미한다. 

문자열은 문자들이 메모리 공간에 연속적으로 저장됨= 주소로 관리.
시작 주소를 알면 저장된 문자들에 접근 가능

문자열 배열 
char array[]="ABCD"

char array2[]={'A','B','C','D'}를 %s로 출력하면 에러다. 문자 배열인 것이다.뒤에 \0을 추가해주면 해결

char* p="ABCD"의 경우에 문자열 상수 "ABCD"는 비록 이름이 없지만 메모리 공간에 저장(주소를 가짐)

char* const p=&a    p=&a 상수화.  
포인터 변수에 다른 메모리 공간의 주소를 저장 x

const char* p=&a    *p를 상수화 
메모리 공간의 값을 변경x

const char* const p=&a 
메모리 공간의 주소와 값 모두 변경 x 

*/

#include <stdio.h>

int main()
{
    char *string[2] = {"I Love C", "Hello World"};
    printf("%s%s", string[0], string[1] + 5);
    ` return 0;
}