//12장 포인터

/*
포인터 변수는 메모리 공간의 주소를 알려주면 해당 주소를 기억/저장하다가 해당 주소에 간접적으로 접근하게 해준다. 
변수는 데이터를 저장. 포인터는 메모리 공간의 주소를 저장.(&연산자)

int* pointer=NULL;
NULL=아무 주소도 저장하지 않겠다는 말. 아스키 값으로 0

32비트 운영채재를 기준으로 포인터 변수는 모두 4바이트의 크기를 가집니다. 
다양한 타입의 포인터 변수가 있는 이유= 몇 바이트씩 참조해야하는지 알려줘야함.

char* cp=&c 처럼 선언과 동시에 주소를 저장할 수도 있다. 
포인터 변수가 각각 저장된 주소는 포인터가 가리키는 변수의 주소와 다르다
*cp=10;  처럼 포인트 변수에 값을 지정해주면 포인터가 가리키는 주소에 값이 저장된다. 


다차원 포인터
2차원 이상의 포인터 변수는 포인터 변수의 주소를 저장하는 변수 n차원 포인터 변수는 n-1 차원 포인터 변수의 주소를 저장
포인터 변수의 데이터는 포인터 변수가 가리키는 데이터와 다르다. 

char c='A'
char* cp=NULL
cp=&c

cp의 데이터는 c의 주소 데이터와 동일
데이터와 값은 포인터로 전달이 되어도 주소는 변함없다. 

주소의 가감산
char+1 1증가
int +1 4바이트 증가 1차원 포인터의 주소의 경우에도 4증가`
dobule +1 8바이트 증가

*(array+i) == array[i]

함수가 있는 메모리 공간의 주소=함수 이름
배열 이름=배열 시작 주소. 함수 이름=함수 시작 주소

함수 포인터= int (*add)(int,int)
pointer=add
pointer(x,y) 
이런식으로 add함수의 매개변수에 x,y값을 전달할 수 있다.




*/

#include <stdio.h>
void arrInput(int val1[], int val2);
int main()
{

    void (*pfunc)(int[], int);

    int array[5] = {10, 20, 30, 40, 50};

    pfunc = arrInput;
    pfunc(array, 5);

    return 0;
}

void arrInput(int val1[], int val2)
{
    for (int i = 0; i < val2; i++)
    {
        printf("%d, ", val1[i]);
    }
}
